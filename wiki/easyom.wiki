#summary EasyOM - Easy Object Mapping

I'm still working on this......

= About =
EasyOM and not EasyORM because it's not an ORM.  This class allows you to persist single objects to the database by adding persistence methods to entity classes.  It also adds methods that allow you to execute "StringQueries".  

= Configuration =

Use the following 2 methods to configure EasyOM.

==== public static void init(java.lang.Properties propFile) ====  
  Initializes the internal properties and datbase properties used for database operations

==== public static void injectMethods(java.lang.Class clazz) ====
  Adds methods to the specified class for persistence and querying.

To initialize EasyOM and to add the persistence methods to an application's entity classes, invoke the methods like so:

{{{
   // or some other type of bootstrap method
   def onApplicationStart(app){
       EasyOM.init(loadPropertiesFile("db.properties"))

       EasyOM.injectMethods(model.EntityObject1.class)
       EasyOM.injectMethods(model.EntityObject2.class)
       EasyOM.injectMethods(model.EntityObject3.class)
   }
}}}

The properties file expected by EasyOM.init() must have the follow name value pairs
|| *Property*|| *Description*||
||db.driver || The database driver name||
||db.url || Database connection url ||
||db.username || Database username||
||db.password || Database password ||
||use.table.prefix|| when 'true', a specified prefix will be prefixed to the entity name.  ie, if the entity name is "User", but the table name is "tblUser" set this property to true and set table.prefix ||
||table.prefix|| The table prefix. Use with "use.table.prefix" ||
||camel.case.table.name|| set true when underscores in table name should be converted to camel cased entity name||
||camel.case.column.name|| set true when underscores in column names should be converted to camel cased column name ||

== Configuring Entity Objects ==
To persist an entity object, the entity has to have 2 additional attributes in addition to its properties.
|| *Property* || *Description* ||
|| List primaryKeys || List of primary key columns ||
|| List dynamicProperties || This list is used to store the names of columns changed since the persistence method invocation.  It ensures that only the properties updated are included in insert and update queries. ||

= Persistence Methods =
The following methods are added to each object, injectMethods() is invoked on. Each method operates on "this" or the current object.  The methods don't accept any arguments  and all return an Integer indicating the number records affected by the query.

|| public Integer insert() ||  executes an insert statement for the entity for properties that have set since the last persistence method invocation||
|| public Integer  update() ||  executes an update statement for the entity for properties that have set since the last persistence method invocation ||
|| public Integer save() || executes an insert if the primary key(s) has no value, otherwise executes an update query ||
|| public Integer delete() || deletes a this object from the table ||

Example:
{{{
   def insertNewUser(username, lastName, firstName){
     User user = new User(username: username, firstName: firstName, lastName: lastName)
     // insert new user, could have used user.save()
     user.save()

     // now the the user
     user.delete()
  }
}}}

*Static Methods*
|| public static Integer delete() || deletes a row from the table ||
|| static def find() || Returns a single entity ||
|| static def findAll() || Returns a list of entity objects ||
|| static def list() || Returns all of the entity objects in the table(unless paging parameters specified)||


*StringQueries*: The following methods are added to the String class
|| executeQuery || Executes a SELECT query ||
|| executeUpdate || Used to execute insert, update and delete queries  ||
|| executeScalar || Executes a SELECT query and returns a single value (column 1 of the first row)||


==Static Methods - WHERE clause ==

*find()*, *findAll()*, and *delete()* all accept a map with name value pairs that let your specify how the queries WHERE clause is crafted.  You can also only specify one type of logical operator: 'AND' or 'OR'. If no operator is specified, the 'AND' operator is assumed. There is no limit on the number of columns that can be in the WHERE clause.

{{{
    // returns first object in resultset where last name equals 'Smith' and first name equals 'John'
    // find only returns 1 object 
    User user = User.find([lastName:'Smith', firstName:'John'])
    
    //Returns a list of User objects where the last name is 'Smith' or 'Williams'
    List users = User.findAll( operator:'OR', [lastName:'Smith', lastName:'Williams'])

    //Deletes all objects from User table where lastname = 'Harrison'
    User.delete([lastName:'Harrison'])
    
}}}


==Static Methods - ORDER BY clause ==
To specify the where order by clause for *findAll()* or *list()*, simple add an 'orderBy'
to the parameters map with a comma seperator list of column/property names.

{{{
    //Returns a list of User objects where state = 'FL' ordered By, the state column, then the lastName column in ascending order
    List users = User.findAll( operator:'OR', [state:'FL', orderBy:'state, lastName'])

    //Returns a list of User objects where state = 'FL' ordered By, the state column in ascending order, folloed by lastName column in descending order
    List users = User.findAll( operator:'OR', [state:'FL', orderBy:'state, lastName DESC'])   
}}}

==Static Methods - Paging ==
To specify paging options for findAll or list(), include a page and pageSize keys with values, to the parameters map.  The returned object will be a Map.  The map will contain the following:


Paged Result Map
|| *Key* || *Value* || 
|| recordCount || the total number of records in the DB for the specified query ||
|| page || The current page of the result set ||
|| pageCount || The total number of pages in the query results || 
|| results || A list of GroovyRowResult objects, or a list of the specified return type ||


== StringQueries ==
String queries allow you to do call an "execute" query method on a simple String. 

{{{
    // returns the total number of records in table tblUser
    def getTotalRecordCount(){
       "SELECT count(*) FROM tblUser".executeScalar()
    }
}}}

StringQueries can be executed with queries parameters, paging options and/or the object return type.  [stringQueries See all of the options here].